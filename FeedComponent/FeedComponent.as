package {    import com.gskinner.motion.GTween;    import com.gskinner.motion.easing.Sine;        import config.*;        import flash.display.DisplayObject;    import flash.display.MovieClip;    import flash.display.Sprite;    import flash.events.Event;    import flash.events.IOErrorEvent;    import flash.events.MouseEvent;    import flash.events.TimerEvent;    import flash.geom.Point;    import flash.geom.Rectangle;    import flash.net.URLVariables;    import flash.system.Security;    import flash.text.TextField;    import flash.utils.Timer;        import items.*;        import utils.*;    /**     * Feed Component     *     * Three components that load a feed, parse it, and display the content therein.     *     * Future extensions: pre-fetch of feed images (so that navigation/render is immediate); sexifying     * of the transitions (more types, header/footer slide into place rather than just appearing, on slide     * transition previous page slides out rather than masking out).     *     */    [Build(type="component")]    public class FeedComponent extends Sprite {        ////////// Flite Namespace        public namespace flite = "http://www.flite.com/ad/v3/component/namespace";        ////////// Class variables        // Event types.        public static const ITEM_RENDER_COMPLETE:String = "Item Render Complete";        public static const FULL_VIEW_LOAD:String = "Loading Full View";        public static const FULL_VIEW_IMAGE_LOADED:String = "Loaded Full View";        public static const FULL_VIEW_INITIAL_TRANSITION:String = "Initial Transition Full View";        public static const FULL_VIEW_TRANSITION:String = "Transition Full View";        // Error handling.        public static const FEED_ERROR_TITLE:String = "There was an error retrieving the feed.";        public static const FEED_ERROR_MESSAGE:String = "Please verify the feed and fix any issues.";        public static const FEED_ERROR_UNRECOGNIZED:String = "The feed type was not recognized; please verify that the feed is valid.";        // Mostly layout constants.        public static const ITEMS_RIGHT_MARGIN:uint = 10;        public static const SCROLLBAR_MARGIN:uint = 5;        public static const HEADER_HEIGHT:uint = 28;        public static const FOOTER_HEIGHT:uint = 28;        public static const FEED_SEPARATOR_ALPHA:Number = 0.5;        public static const FULL_VIEW_HEADER_FOOTER_COLOR:uint = 0xC6C6C6;        public static const FULL_VIEW_HEADER_FOOTER_ALPHA:Number = 0.88;        //	public static const SCROLL_HEIGHT_PADDING:uint = -20;        public static const NAV_BUTTON_MOUSE_OUT_ALPHA:Number = 0.70;        public static const NAV_BUTTON_MOUSE_OVER_ALPHA:Number = 0.92;        public static const NAV_BUTTON_MOUSE_DOWN_ALPHA:Number = 1.0;        public static const FOOTER_NAV_BUTTON_SIZE:uint = 6;        public static const NAV_BUTTON_COLOR:uint = 0x000000;        public static const FOOTER_PREV_NEXT_BUTTON_MARGIN:uint = 10;        public static const NEXT_BUTTON_HEIGHT:uint = 10;        public static const NEXT_BUTTON_WIDTH:uint = 14;        public static const HEADER_NAV_TEXT_COLOR:uint = 0xFFFFFF;        public static const HEADER_NAV_TEXT_FONT:String = "Helvetica";        public static const HEADER_NAV_TEXT_SIZE:uint = 10;        public static const HEADER_NAV_BUTTON_HEIGHT:uint = 20;        public static const HEADER_NAV_READ_MORE_BUTTON_WIDTH:uint = 76;        public static const HEADER_NAV_BACK_BUTTON_WIDTH:uint = 40;        public static const HEADER_NAV_BACK_BUTTON_TRIANGLE_HEIGHT:uint = 10;        public static const HEADER_NAV_BUTTON_CORNER_ELLIPSE_RADIUS:uint = 8;        public static const HEADER_NAV_BACK_BUTTON_CURVE_SIZE_X:uint = 3;        public static const HEADER_NAV_BACK_BUTTON_CURVE_SIZE_Y:uint = 2;        //	public static const VERTICAL_SPACING:uint = 10;        ////////// Member Variables        /**         * The current layout type of the Component; deprecated, but left commented         * out for potential future extensibility.         */        //		protected var _currentLayoutType:String;        /**         * Each of the feed items (parsed from XML into individual Objects).         */        protected var _entries:Array;        /**         * A reference to the AdAPI from the Flite Ad Runtime         */        protected var _api:Object;        protected var _metricsUtil:MetricsUtils;        /**         * A config map (key, value) containing component specific config.         * Relayed from the API.         */        protected var _config:FeedComponentConfig;        /**         * A rectangle representing the configured width, height and position of the component,         * and of the items' view area.         */        protected var _rectangle:Rectangle;        /**         * Stores pages (simply Sprite containers) in sequential order, using memoization such that its elements only         * call render() when each page has yet to be loaded.         */        protected var _pages:Array;        protected var _numItemsRenderedEachPage:Array;		protected var _itemYCoords : Vector.<Number>;        /**         * An indication of the current and next (desired) pages, to support pagination of results when a max         * (feed item) value is specified.         */        protected var _currentPage:uint;        protected var _nextPage:uint;        protected var _itemsPerPage:uint;        protected var _isAutoScrollTimerQueued:Boolean;        protected var _fullViewXMargin:Number;        protected var _listViewXMargin:Number;        protected var _fullView:FeedItemFullView;        protected var _fullViewContainer:Sprite;        protected var _fullViewHeader:Sprite;        protected var _fullViewFooter:Sprite;        protected var _listViewScrollbar:MovieClip;        protected var _fullViewScrollbar:MovieClip;        protected var _spinner:MovieClip;        // For metrics.        protected var _feedName:String;        // Race condition management.        protected var _isTransitioning:Boolean;        protected var _isFirstTransition:Boolean;        protected var _isFullViewLoading:Boolean;        // For "navigation" control type.        protected var _footer:Sprite;        protected var _prevPageButton:Sprite;        protected var _nextPageButton:Sprite;        protected var _scrollbarWidth:Number;        protected var _autoScrollTimer:Timer;        // Dependencies.        /**         * A feed parsing utility, retrieved from the API         */        protected var _feedParser:Object;        /**         * A feed proxy utility, used to load feeds cross domain, retrieved from the API         */        protected var _feedProxy:Object;        ////////// Constructor        public function FeedComponent() {            trace('NEW FEED COMPONENT GETTING CONSTRUCTED!!!!!');            Security.allowDomain("*");        }        ////////// Flite Ad Runtime Component Interface Methods        /**         * apiInit         *         * Invoked by the Flite Ad Runtime when the component has finished loading; essentially the 'main()'         * entry point for the component.         *         * @param options - a map of values. Most importantly "api" which holds a reference         *                  to the Flite AdAPI         *                  width - the width         *                  height - the height         *                  config - Component specific config         *                  children - If the component is a container, this will have a list of children         */        flite function initialize(options:Object):void {            trace("api init");            _api = options.api;            trace("got api");            _metricsUtil = new MetricsUtils(options);            _config = simpleFeedConfigFactory(options.config);            trace("got config");            _pages = new Array();            trace("got rect");            resize(options);            _numItemsRenderedEachPage = new Array();            // Edge case handling - so that first page will render (rather than returning            // as the default value for uint is 0 (ie. the 'current page').            _currentPage = uint.MAX_VALUE;            _feedParser = _api.factory.getFeedParser();            trace("got feed parser " + _feedParser);            _feedProxy = _api.factory.getFeedProxy();            trace("got feed proxy " + _feedProxy);            Utils.setApi(_api);            _scrollbarWidth = _api.factory.getTheme().getScrollbar({}).width;            _fullViewXMargin = getFullViewXMargin();            _listViewXMargin = getListViewXMargin();            trace('********* end of api init *****');        }        protected function initContent():void        {            _feedProxy.addEventListener(Event.COMPLETE, feedProxy_COMPLETE);            trace('after getting feed proxy');            _feedProxy.addEventListener(IOErrorEvent.IO_ERROR, feedProxy_IO_ERROR);            trace("loading feed " + _config.sourceUrl);            if (!hasEventListener(FeedComponent.FULL_VIEW_LOAD))            {                addEventListener(FeedComponent.FULL_VIEW_LOAD, fullView_LOAD, true);            }            // TimeAgo            _feedProxy.loadFeed(_config.sourceUrl, {dateFormat: 'yyyy-MM-dd HH:mm:ss Z', tags:true});//, {minify: false});            showSpinner();            _isAutoScrollTimerQueued = true;        }        /**         * resize         *         * Invoked by Flite Ad Runtime whenever the component needs to redraw or resize at a         * new set of dimensions         *         * @param options - a map containing width and height         */        protected function resize(options:Object):void        {            trace('resizing to dimensions', options.width, options.height);            var previousWidth:Number = (_rectangle) ? _rectangle.width : 0;            if (!_rectangle)            {                _rectangle = new Rectangle(0, 0, options.width, options.height);            }            else            {                _rectangle.width = options.width;                _rectangle.height = options.height;            }            var previousNumItemsPerPage:uint = _itemsPerPage;            calculateNumItemsPerPage();            if (previousNumItemsPerPage != _itemsPerPage || previousWidth != _rectangle.width)            {                // Force re-render of all pages.                for (var i:uint = 0; i < _pages.length; i++)                {                    Utils.destroySprite(_pages[i]);                }                _pages.length = 0;                if (_config.controlMode == FeedComponentConfig.CONTROL_MODE_PAGINATION && _entries)                {                    addPageNavigation();                }            }            // Force re-draw of full view header (when the time comes).            if (_fullViewHeader)            {                Utils.destroySprite(_fullViewHeader);            }            _isFirstTransition = true;        }        /**         * stateChange         *         * Invoked by the Flite Ad Runtime whenever there is a change in state.         *         * @param options - TDB         */        flite function stateChange(options:Object):void {            // options.state == "active" || "inactive" || 1. "loaded" || 2. "initialized" (after api init)            //trace('\nstate changed event fired!! New state is',options.state,'\n');            if (options.trigger) {                _metricsUtil.initalMetricsHelper = options.trigger;            }            switch(options.state)            {                case _api.state.ENABLED:					_isAutoScrollTimerQueued = true;					startAutoScrollTimer();                    if (!_entries)                    {                        initContent();                    }                    break;                case _api.state.DISABLED:                    if (_autoScrollTimer)                    {                        // Note that reset() also stops the timer.                        _autoScrollTimer.reset();                    }                    break;                default:                    break;            }        }        /**         * Client-facing interface for page navigation.         */        public function set currentPage(page:uint):void {            gotoPage(page);        }        /////////// Private Methods        ////////// Methods which render feed items.        /**         * Renders each of the items.  Assumes that each item has been         * parsed into objects from the XML.         */        protected function renderItemsToPage(containerSprite:Sprite, pageIndex:uint = 0):void {            var currentFeedItemLocation:Point = new Point(0, 0);			_itemYCoords = new Vector.<Number>;            // Pagination.            var startValue:uint = pageIndex * _itemsPerPage;            var endValue:uint = Math.min((pageIndex + 1) * _itemsPerPage, _entries.length);            // Adding here precludes race condition in which all 'render complete' events for this page            // are dispatched before this function returns.            _pages[pageIndex] = containerSprite;            var currentFeedItem:AbstractFeedItemView;            var additionalMargin:uint = (_config.controlMode == FeedComponentConfig.CONTROL_MODE_SCROLLBAR) ? 2 * SCROLLBAR_MARGIN + _scrollbarWidth: 0;            for (var i:uint = startValue; i < endValue; i++)            {                currentFeedItem = renderItem(_entries[i], currentFeedItemLocation.x, currentFeedItemLocation.y, containerSprite);                currentFeedItemLocation = currentFeedItemLocation.add(getFeedItemPositionOffset(currentFeedItem));				_itemYCoords[i] = currentFeedItem.y;				trace(FeedComponent, ".renderItemsToPage - currentFeedItem pos:", currentFeedItem.x, currentFeedItem.y);                // Draw the divider.                if (i != endValue - 1)                {                    containerSprite.graphics.beginFill(_config.separatorColor, FEED_SEPARATOR_ALPHA);                    containerSprite.graphics.drawRect(currentFeedItemLocation.x, currentFeedItemLocation.y, _rectangle.width - additionalMargin, 1);                    containerSprite.graphics.endFill();                }            }        }        /**         * renderItem         *         * A forEach method called on a list of article items. Creates a text field and positions it accordingly.         * Populates the text field with the article title.         *         * @param item - the article being rendered         * @param id - index in the array         * @param list - the rest of the array, for reference.         *         * Allows for live view change.         */        protected function renderItem(itemModel:Object, xPos:Number, yPos:Number, container:Sprite):AbstractFeedItemView        {            var itemView:AbstractFeedItemView = simpleFeedItemFactory(itemModel);            itemView.x = xPos;            itemView.y = yPos;            container.addChild(itemView);            itemView.fullViewXMargin = _fullViewXMargin;            var itemHeight:uint = _config.itemHeight;            itemView.render(_rectangle.width - _listViewXMargin, itemHeight);            return itemView;        }        //////// Navigation member functions.        /**         * Manager/controller for page navigation - where all the magic happens.         */        protected function gotoPage(page:uint):void {trace('\n\ngoing to page',page,'and current page is',_currentPage,'and is transitioning is',_isTransitioning,'\n\n');            if (page == _currentPage || _isTransitioning)            {                return;            }            if (_fullView)            {                _fullView.visible = false;            }            _nextPage = page;            // Show/hide the next/prev buttons if we're in pagination mode.            if (_config.controlMode == FeedComponentConfig.CONTROL_MODE_PAGINATION)            {                if (page == 0)                {                    _prevPageButton.visible = false;                }                else if (_currentPage == 0)                {                    _prevPageButton.visible = true;                }                var numPages:uint = Math.ceil(_entries.length / _itemsPerPage);                if (page == numPages - 1)                {                    _nextPageButton.visible = false;                }                else if (_currentPage == numPages -1)                {                    _nextPageButton.visible = true;                }            }            // Memoization in effect - cache each page so that you only            // need to render each page's items once.            if (!_pages[page])            {                showSpinner();                _numItemsRenderedEachPage[page] = 0;                if (!hasEventListener(ITEM_RENDER_COMPLETE))                {                    addEventListener(ITEM_RENDER_COMPLETE, itemRender_COMPLETE, true);                }                var containerSprite:Sprite = new Sprite();                containerSprite.visible = false;                addChild(containerSprite);                renderItemsToPage(containerSprite, page);            }            else            {                // Retrieve the page from the array, and transition to it.                transitionToNextPage();            }            _isTransitioning = true;        }        protected function gotoNextPage(isAutoScroll:Boolean):void        {            var numPages:uint = Math.ceil(_entries.length / _itemsPerPage);            var targetPage:uint = (_currentPage + 1) % numPages;trace('target page is',targetPage);            if (!isAutoScroll)            {                _metricsUtil.logFeedNav(String(targetPage), "next");            }            gotoPage(targetPage);        }        protected function gotoPrevPage(event:Event = null):void        {            var numPages:uint = Math.ceil(_entries.length / _itemsPerPage);            // If the current page is zero, go to the last page.            _currentPage ||= numPages;            var targetPage:uint = (_currentPage - 1) % numPages;            _metricsUtil.logFeedNav(String(targetPage), "prev");            gotoPage(targetPage);        }        /**         * Catches Event dispatched by each item view when it has rendered its content;         * begins transition to next page (which displays its content) once every item         * has dispatched an ITEM_RENDER_COMPLETE Event.         */        protected function itemRender_COMPLETE(event:Event):void        {            trace('item render event caught in feed component!!');            var numItemsThisPage:uint = _itemsPerPage;            // If we're on the last page...            if (_config.controlMode == FeedComponentConfig.CONTROL_MODE_PAGINATION || _config.controlMode == FeedComponentConfig.CONTROL_MODE_NONE)            {                if (_nextPage > _entries.length / _itemsPerPage - 1)                {                    numItemsThisPage = _entries.length % _itemsPerPage;                }                else if (_isFirstTransition && _entries.length < _itemsPerPage)                {                    numItemsThisPage = _entries.length;                }            }            else if (_config.controlMode == FeedComponentConfig.CONTROL_MODE_SCROLLBAR && _isFirstTransition)            {                // As many as can fit on one page...                numItemsThisPage = getNumItemsViewable();            }            if (++_numItemsRenderedEachPage[_nextPage] == numItemsThisPage)            {                removeEventListener(event.type, arguments.callee, true);                //				removeEventListener(FeedComponent.ITEM_RENDER_COMPLETE, itemRender_COMPLETE);                transitionToNextPage();            }        }        // This is where the next page is shown - once all the items have rendered to page, or        // (if that page is already cached) right away!        protected function transitionToNextPage():void        {            trace('\ntransitioning page from',_currentPage,'to',_nextPage);            var transitionType:String = _config.transitionType;            if (_isFirstTransition)            {                transitionType = FeedComponentConfig.TRANSITION_TYPE_FADE;                _isFirstTransition = false;            }            // TDFD: Note that initialX is only used by the slide transition...            var initialX:Number = (_nextPage < _currentPage) ? -_rectangle.width : _rectangle.width;            animateContentIn(initTransitionToNextPage, _pages[_nextPage], null, transitionType, initialX, transitionToPage_COMPLETE);        }        protected function initTransitionToNextPage():void        {            addChildAt(_pages[_nextPage], 0);        }        /**         * Bottleneck method for all transitions; new transition types will need to be added here, and fit into the various methods that call         * this function.         * Note that any function that calls this method, if it performs any initialization whatsoever (especially         * manipulating the display list) needs to first see if a transition is in progress, and return if it is.         */        protected function animateContentIn(initFunction:Function, content:Sprite, prevContent:Sprite, transition:String, initialCoord:Number, callback:Function = null, initFunctionArg:Object = null):void        {            // Potential future config param...            //			var easingFunction:Function = Regular.easeIn;            hideSpinner();            trace('animating in content!');            // Only pass a function into the init function if it's necessary.  Note that assigning content to            // the result of this call is a hack to fix the _fullView is null the first time through error.            (initFunctionArg) ? (content = initFunction.call(this, initFunctionArg)) : initFunction.call(this);            hideListViewScrollbar();            hideFullViewScrollbar();            _isTransitioning = true;            prevContent ||= _pages[_currentPage];            switch (transition)            {                case FeedComponentConfig.TRANSITION_TYPE_FADE:                    fadeContentIn(content, prevContent, callback);                    break;                case FeedComponentConfig.TRANSITION_TYPE_SLIDE:                default:                    slideContentIn(content, prevContent, initialCoord, callback);                    break;            }        }        /**         * Hide full view on list view transition in (avoid race condition in pagination and scroll modes).         *         * Hide/show bottom navigation on full view in/out (or make full view larger)         *         * Make rander area less wide in call to item.render on scrollbar control type.         */        protected function slideContentIn(content:Sprite, prevContent:Sprite, initialCoord:Number, callback:Function = null):void        {            var interval:Number = 1000 / stage.frameRate;            var repeatCount:uint = stage.frameRate * _config.transitionAnimationTime;            // If the user entered "0" for the transition time, it should be instant (ie. no transition).            repeatCount ||= 1;            content.x = initialCoord;            content.visible = true;            moveFooterToTopOfDisplayList();            var tween1:GTween = new GTween(content, _config.transitionAnimationTime);            var tween2:GTween = new GTween(prevContent, _config.transitionAnimationTime);            tween1.ease = tween2.ease = Sine.easeIn;            tween1.setValue("x", 0);            tween2.setValue("x", -initialCoord);            tween1.onComplete = tween_COMPLETE;            if (_config.controlMode == FeedComponentConfig.CONTROL_MODE_PAGINATION) {                var tween4:GTween = new GTween(_footer, _config.transitionAnimationTime);                tween4.ease = Sine.easeIn;                tween4.setValue("x", (content == _fullViewContainer) ? -initialCoord : 0);            }            function tween_COMPLETE(tween:GTween):void            {                content.visible = true;                content.x = 0;                if (callback != null)                {                    callback.call(this, null);                }            }        }        protected function initFadeContent(content:Sprite, isTransitioningToOrFromFullView:Boolean, prevContent:Sprite = null):void        {            if (prevContent)            {                prevContent.visible = true;                prevContent.x = content.x;                prevContent.alpha = 1;            }            if (isTransitioningToOrFromFullView)            {                if (_footer)                {                    if (content == _fullViewContainer)                    {                        _footer.alpha = 1;                    }                    else                    {                        _footer.alpha = 0;                    }                    _footer.visible = true;                }            }            content.alpha = 0;            content.visible = true;            moveFooterToTopOfDisplayList();        }        // TODO: This method has gotten too funky; need to push some of the complexity out; consider including additional        // parameters - 'additional_stuff_to_fade_in', 'additional_stuff_to_fade_out'        protected function fadeContentIn(content:Sprite, prevContent:Sprite = null, callback:Function = null) : void        {            var interval:Number = 1000 / stage.frameRate;            var repeatCount:uint = stage.frameRate * _config.transitionAnimationTime;            // If the user entered "0" for the transition time, it should be instant (ie. no transition).            repeatCount ||= 1;            var deltaAlpha:Number = 1 / repeatCount;            var additionalListViewContentDeltaAlpha:Number = (content == _fullViewContainer) ? -deltaAlpha : deltaAlpha;            var isTransitioningToOrFromFullView:Boolean = (content == _fullViewContainer || prevContent == _fullViewContainer);            initFadeContent(content, isTransitioningToOrFromFullView, prevContent);            var timer:Timer = new Timer(interval, repeatCount);            timer.addEventListener(TimerEvent.TIMER, function(e:Event):void            {                content.alpha += deltaAlpha;                if (prevContent)                {                    prevContent.alpha -= deltaAlpha;                }                if (_config.controlMode == FeedComponentConfig.CONTROL_MODE_PAGINATION && isTransitioningToOrFromFullView)                {                    _footer.alpha += additionalListViewContentDeltaAlpha;                }            });            timer.addEventListener(TimerEvent.TIMER_COMPLETE, function(e:Event):void            {                content.alpha = 1;                if (_config.controlMode == FeedComponentConfig.CONTROL_MODE_PAGINATION)                {                    if (content == _fullViewContainer)                    {                        _footer.visible = false;                    }                    else                    {                        _footer.alpha = 1;                    }                }                if (callback != null)                {                    callback.call(this, e);                }            });            timer.start();        }        protected function moveFooterToTopOfDisplayList():void        {            if (_footer)            {                setChildIndex(_footer, numChildren - 1);            }        }        protected function transitionToPage_COMPLETE(event:Event = null):void        {            trace('transition to page complete callback running');            if (_pages[_currentPage])            {                _pages[_currentPage].visible = false;            }            // Hide and dispose of the bitmap.            if (_footer) //_config.controlMode = FeedComponentConfig.CONTROL_MODE_PAGINATION)            {                var currentButton:DisplayObject;                // Recall that current page is initialized to max_value to indicate 'first run'.                if (_currentPage != uint.MAX_VALUE)                {                    // This here is throwing an error.                    currentButton = _footer.getChildByName('button' + _currentPage);                    if (currentButton)                    {                        currentButton.alpha = NAV_BUTTON_MOUSE_OUT_ALPHA;                    }                }                currentButton = _footer.getChildByName('button' + _nextPage);                if (currentButton)                {                    currentButton.alpha = NAV_BUTTON_MOUSE_OVER_ALPHA;                }            }            if (_nextPage == 0 && _config.controlMode == FeedComponentConfig.CONTROL_MODE_SCROLLBAR)            {                showListViewScrollbar();            }            if (_isAutoScrollTimerQueued)            {                startAutoScrollTimer();            }            _isTransitioning = false;            _currentPage = _nextPage;        }        //// Methods for transitioning among the list/full views.        protected function fullView_LOAD(event:Event):void        {            if (_isFullViewLoading || _isTransitioning)            {                return;            }            showSpinner();            if (!hasEventListener(FeedComponent.FULL_VIEW_TRANSITION))            {                addEventListener(FeedComponent.FULL_VIEW_TRANSITION, showFullView, true);                addEventListener(FeedComponent.FULL_VIEW_INITIAL_TRANSITION, showFullView, true);            }            _isFullViewLoading = true;        }        protected function showFullView(event:Event):void        {            // Remember that if the full view has already been instantiated by the feed item            // view, then FULL_VIEW_TRANSITION will be dispatched by the feed item directly; so            // if the user double-clicks the feed item, control will get here and should return if            // if the feed item is currently loading.            if (_isTransitioning || (_isFullViewLoading && event.type == FULL_VIEW_TRANSITION))            {                return;            }            if (!hasEventListener(FULL_VIEW_IMAGE_LOADED))            {                addEventListener(FULL_VIEW_IMAGE_LOADED, function(e:Event):void                {                    trace('full view image loaded!!!');                    addEventListener(Event.ENTER_FRAME, function(e:Event):void                    {                        showFullViewScrollbar();                        removeEventListener(e.type, arguments.callee);                    });                    removeEventListener(e.type, arguments.callee);                }, true);            }            _isTransitioning = true;            _isFullViewLoading = false;            animateContentIn(initShowFullView, _fullViewContainer, null, _config.transitionType, _rectangle.width, showFullView_COMPLETE, (event.target as FeedItemView).fullView);        }        protected function initShowFullView(fullView:Object):Sprite        {            if (!_fullViewContainer) {                _fullViewContainer = new Sprite();                addChild(_fullViewContainer);            }            _fullView = fullView as FeedItemFullView;            _fullView.y = HEADER_HEIGHT;            _fullView.visible = true;            _fullViewContainer.addChildAt(_fullView, 0);            addFullViewHeader();            addFullViewFooter();            _metricsUtil.logArticleContent(_fullView.title, _fullView.linkUrl);            return _fullViewContainer;        }        // TODON: Fix a scrollbar bug wherein the scrollbar is going 1px too low in the scroll track.        protected function showFullView_COMPLETE(event:Event):void        {            _pages[_currentPage].visible = false;            showFullViewScrollbar();            _isTransitioning = false;        }        protected function showListView(event:Event = null):void        {            if (_isTransitioning)            {                return;            }            _isTransitioning = true;            _metricsUtil.logArticleInteraction("Back");            animateContentIn(initShowListView, _pages[_currentPage], _fullViewContainer, _config.transitionType, -_rectangle.width, showListView_COMPLETE);        }        protected function initShowListView():void        {            if (getChildIndex(_fullViewContainer) > getChildIndex(_pages[_currentPage]))            {                swapChildren(_pages[_currentPage], _fullViewContainer);            }        }        protected function showListView_COMPLETE(e:Event):void        {            if (_currentPage == 0 && _config.controlMode == FeedComponentConfig.CONTROL_MODE_SCROLLBAR)            {                showListViewScrollbar();            }            _fullViewContainer.removeChild(_fullView);            _fullView = null;            _isTransitioning = false;        }        /**         * Depending on the current layout type (only one in current implementation), effectively         * returns the location of where the next feed item should be placed.  Currently feed items         * are only layed out vertically on the page, but future implementations (ticker, for instance)         * may position them horizontally.         */        protected function getFeedItemPositionOffset(feedItem:AbstractFeedItemView):Point        {            return new Point(0, feedItem.displayHeight);        }        ////////// Feed Proxy Event Methods        /**         * feedProxy_IO_ERROR         *         * @param event - IOErrorEvent sent when feed does not load properly.         */        protected function feedProxy_IO_ERROR(event:IOErrorEvent):void {            _feedProxy.removeEventListener(Event.COMPLETE, feedProxy_COMPLETE);            _feedProxy.removeEventListener(IOErrorEvent.IO_ERROR, feedProxy_IO_ERROR);            trace('feed proxy error is',event);            showFeedError(FEED_ERROR_TITLE, FEED_ERROR_MESSAGE);        }        protected function showFeedError(errorTitle:String, errorContent:String):void        {            var container:Sprite = new Sprite();            _pages[0] = container;            _nextPage = 0;            var itemView:AbstractFeedItemView = renderItem({title: errorTitle, content: errorContent}, 0, 0, container);            // Remove interactivity for the item.            var currentChild:DisplayObject;            for (var i:uint = 0; i < itemView.numChildren; i++)            {                currentChild = itemView.getChildAt(i);                if (currentChild is Sprite)                {                    (currentChild as Sprite).buttonMode = false;                }            }            itemView.addEventListener(MouseEvent.CLICK, function(e:Event):void { e.stopImmediatePropagation(); }, true);            transitionToNextPage();        }        /**         * feedProxy_COMPLETE         *         * On feed load completion, we get the article list and render the items.  Essentially, this         * function here is what starts the action.         *         * @param event - Event sent when feed has loaded.         */        protected function feedProxy_COMPLETE(event:Event):void {            _feedProxy.removeEventListener(Event.COMPLETE, feedProxy_COMPLETE);            _feedProxy.removeEventListener(IOErrorEvent.IO_ERROR, feedProxy_IO_ERROR);            var feed:XML = event.target.feed;            /*            Parsing fields:            imageUrl, content, title, linkUrl, xml            Sample feed output...            <entry>            <title type="html"><![CDATA[I {Code} QR]]></title>            <link rel="alternate" href="http://www.iherebydecree.com/archive/id/902"/>            <updated>2010-10-28T09:08PDT</updated>            <published>2010-10-28T09:08PDT</published>            <dc:date>2010-10-28T09:08PDT</dc:date>            <content type="html"><![CDATA[<br><br><br>Perhaps not an original idea<br><br><br><br><br><br>Just threw this together. Scan it with your phone or other QR reader and visit the site it points you to. Enjoy.]]></content>            <media:thumbnail url="http://media.iherebydecree.com/postimages/icodeqrsmall.jpg"/>            <link rel="enclosure" type="image/jpg" href="http://media.iherebydecree.com/postimages/icodeqrsmall.jpg"/>            <link rel="enclosure" href="http://media.iherebydecree.com/postimages/icodeqrsmall.jpg"/>            </entry>            Sample parsing output...            imageUrl : http://media.iherebydecree.com/postimages/moon.jpg            content : <br><br><br>Moon<br><br><br><br><br><br>ahem.<br><br><br><br><br><br>Update: I'm not sure if this has already been done. It just came to me and I did it. Shared thought? Suppressed memory? Original? Time will tell. <br><br><br><br><br><br>Update 2: Turns out it isn't an original idea, which makes sense.            title : Moon            linkUrl : http://www.iherebydecree.com/archive/id/913            xml :            */            try            {                _entries = _feedParser.parse(feed);            }            catch (error:Error)            {                // TDFD: Log to standard out.                showFeedError(FEED_ERROR_TITLE, FEED_ERROR_UNRECOGNIZED);                return;            }            _feedName = getFeedName(feed);            trace('feed name is',_feedName);            _metricsUtil.logFeedContent(_feedName, _config.sourceUrl);            if (_config.maxItems < _entries.length)            {                _entries.length = _config.maxItems;            }            trace('num entries retrieved from feed is ' + _entries.length + ' and config max items is ',_config.maxItems);            // Randomization.            if (_config.isRandomized)            {                var ordinalArray:Array = Utils.getRandomOrderArray(_entries.length);                var holderArray:Array = new Array(_entries.length);                for (var i:uint = 0; i < _entries.length; i++)                {                    holderArray[i] = _entries[ordinalArray[i]];                }                // TDFD: Is this a memory leak?  Don't think so, no.                _entries = holderArray;            }            calculateNumItemsPerPage();            if (_config.controlMode == FeedComponentConfig.CONTROL_MODE_PAGINATION)            {                addPageNavigation();            }            _isFirstTransition = true;            gotoPage(0);        }        protected function pruneEmptyEntries():void        {            for (var i:int = 0; i < _entries.length; i++)            {                if (_entries[i].content == "")                {                    _entries.splice(i, 1);                    i--;                }            }        }        protected function getFeedName(feed:XML):String        {            var feedString:String = feed.toString();            var startTag:String = "<title><![CDATA[";            var startIndex:int = feedString.indexOf(startTag);            return feedString.substring(startIndex + startTag.length, feedString.indexOf("]]></title>", startIndex));        }        //// Init/add/remove helper methods        protected function showSpinner():void        {            trace('showing spinner',_spinner);            if (!_spinner)            {                var theme:Object = _api.factory.getTheme();                _spinner = theme.getSpinner({});                _spinner.x = _rectangle.x + 0.5 * _rectangle.width;                _spinner.y = _rectangle.y + 0.5 * _rectangle.height;                addChild(_spinner);            }            _spinner.play();            _spinner.visible = true;        }        protected function hideSpinner():void        {            trace('hiding spinner',_spinner);            if (_spinner)            {                _spinner.visible = false;                _spinner.stop();            }        }        // Inits scrollbar passed in, corresponding either to _fullViewScrollbar or _listViewScrollbar.        protected function getScrollbar():MovieClip        {            var theme:Object = _api.factory.getTheme();            var scrollbar:MovieClip = theme.getScrollbar({});            addChild(scrollbar);            return scrollbar;        }        protected function initScrollbar(scrollbar:MovieClip, content:Sprite, scrollHeight:uint, yPos:uint, yOffset:Number = 0):void        {            scrollbar.init(scrollHeight, scrollHeight, content, new Point(0, yOffset));            scrollbar.x = _rectangle.width - scrollbar.width - SCROLLBAR_MARGIN;            scrollbar.y = yPos;        }        // If the list view scrollbar is already on the Display List, you need only hide it or reveal        // it - no need (and bad UX) to re-initialize.        protected function showListViewScrollbar():void        {            hideFullViewScrollbar();            if (_pages[0].height < _rectangle.height)            {                return;            }            if (!_listViewScrollbar)            {                _listViewScrollbar = getScrollbar();                initScrollbar(_listViewScrollbar, _pages[0], _rectangle.height - 2 * SCROLLBAR_MARGIN, SCROLLBAR_MARGIN);                _listViewScrollbar.addEventListener(Event.SCROLL, function(e:Event):void                {                    _metricsUtil.logFeedScrollInteraction(getFeedItemAtPosition(e.target.from), getFeedItemAtPosition(e.target.to));                });            }            else            {                _listViewScrollbar.show();                setChildIndex(_listViewScrollbar, numChildren - 1);            }        }        protected function getFeedItemAtPosition(yPos:uint) : AbstractFeedItemView {            var page:Sprite = _pages[_currentPage];            var len:int = page.numChildren;            for (var i:int = 0; i < len; i++) {                try{                    var feedItem:AbstractFeedItemView = AbstractFeedItemView(page.getChildAt(i));                    if(feedItem.y >= yPos){                        return feedItem;                    }                }catch(error:Error){                    trace("encountered non feedItem in display list.");                }            }            return null;        }        protected function hideListViewScrollbar():void        {            trace('hiding scrollbar for list view',_listViewScrollbar);            if (_listViewScrollbar)            {                _listViewScrollbar.hide();            }        }        protected function showFullViewScrollbar():void        {            hideListViewScrollbar();            var yMargin:Number = HEADER_HEIGHT + ((_fullViewFooter) ? FOOTER_HEIGHT : 0);            // Note that this was throwing an error (undefined)//            trace('trying to show full view scrollbar, fullview height is',_fullView.height,'and visible height is',_rectangle.height - yMargin, 'and all height is',_rectangle.height);            if (_fullView.height < _rectangle.height - yMargin)            {                return;            }            if (!_fullViewScrollbar)            {                _fullViewScrollbar = getScrollbar();                _fullViewScrollbar.addEventListener(Event.SCROLL, function(e:Event):void                {                    _metricsUtil.logArticleScrollInteraction(e.target.from, e.target.to, _fullView.title);                });            }            var scrollHeight:Number = _rectangle.height - yMargin - 2 * SCROLLBAR_MARGIN;            initScrollbar(_fullViewScrollbar, _fullView, scrollHeight, HEADER_HEIGHT + SCROLLBAR_MARGIN, HEADER_HEIGHT);            _fullViewScrollbar.visible = true;        }        protected function hideFullViewScrollbar():void        {            if (_fullViewScrollbar)            {                _fullViewScrollbar.hide();            }            trace('hiding scrollbar for full view',_fullViewScrollbar);        }        protected function startAutoScrollTimer():void        {            trace('starting autoscroll timer!');            if (_isAutoScrollTimerQueued && _config.autoScrollInterval != 0 && _config.controlMode != FeedComponentConfig.CONTROL_MODE_NONE &&                !(_config.controlMode == FeedComponentConfig.CONTROL_MODE_SCROLLBAR && !_listViewScrollbar))            {				if (!_autoScrollTimer) {                	_autoScrollTimer = new Timer(1000 * _config.autoScrollInterval);				}                _autoScrollTimer.addEventListener(TimerEvent.TIMER, autoScrollContent);                _autoScrollTimer.start();            }			_isAutoScrollTimerQueued = false;            addEventListener(MouseEvent.ROLL_OVER, stopAutoScrollTimer);        }        protected function stopAutoScrollTimer(e:Event):void        {            trace('stopping autoscroll timer!');            removeEventListener(e.type, arguments.callee);            if (_autoScrollTimer)            {                _autoScrollTimer.stop();                _autoScrollTimer.removeEventListener(TimerEvent.TIMER, autoScrollContent);                _autoScrollTimer = null;            }        }        protected function autoScrollContent(event:Event):void        {            if (_config.controlMode == FeedComponentConfig.CONTROL_MODE_SCROLLBAR)            {				// determine Y-coord to scroll to.				var contentFinalY:Number;				var contentHeight : Number = _rectangle.height;				trace(FeedComponent, ".autoScrollContent - contentHeight:", contentHeight);				trace(FeedComponent, ".autoScrollContent - _rectangle.height:", _rectangle.height);				var contentMinY:Number = contentHeight - _pages[0].height;				if (_pages[0].y > contentMinY) // Scroll down one page's worth.				{					contentFinalY = _pages[0].y - contentHeight;					// look for partially visible item at top of rectangle. set scroll Y to its top					trace(FeedComponent, ".autoScrollContent - _pages[0].y before adjustment:", _pages[0].y);					trace(FeedComponent, ".autoScrollContent - contentFinalY before adjustment:", contentFinalY);					for (var i:uint = 1, l:uint = _itemYCoords.length; i < l; i++) {						if (_itemYCoords[i] + contentFinalY > 0) {							// if rectangle shorter than item, scroll to next item, else to top of partially visible item//							if (contentHeight > this._config.itemHeight) {							if (contentHeight > _itemYCoords[i] - _itemYCoords[i-1]) {								contentFinalY = -_itemYCoords[i-1];							} else {								trace(FeedComponent, ".autoScrollContent - skipping past end of index:", i-1, ", _itemYCoords[i] - _itemYCoords[i-1]:", _itemYCoords[i] - _itemYCoords[i-1]);								contentFinalY = -_itemYCoords[i];							}							trace(FeedComponent, ".autoScrollContent - contentFinalY AFTER adjustment:", contentFinalY, ", index:", i-1);							break;						}					}										// If determined Y is past bottom of list, scroll ot bottom.					if (contentFinalY < contentMinY)					{						contentFinalY = contentMinY;					}				}				else // If we're at the bottom already, go back to the top.				{					contentFinalY = 0;				}                var tween:GTween = new GTween(_pages[0], _config.transitionAnimationTime);                tween.setValue("y", contentFinalY);                tween.onChange = function(tween:GTween):void                                    {                                        _listViewScrollbar.adjust();                                    };            }            else if (_config.controlMode == FeedComponentConfig.CONTROL_MODE_PAGINATION)            {                gotoNextPage(true);            }        }        /**         * Simple/parameterized factory for generating Feed Items; simply switches on type.         *         * TDFD: Optimization might be to store classes in an array, but that might be even slower.         */        protected function simpleFeedItemFactory(itemData:Object):AbstractFeedItemView        {			return new FeedItemView(_api, itemData, _config, _metricsUtil);        }        protected function simpleFeedConfigFactory(configObj:Object):FeedComponentConfig        {			return new FeedComponentConfig(configObj);        }        ///// Helper methods...        protected function calculateNumItemsPerPage():void        {            switch (_config.controlMode)            {                case FeedComponentConfig.CONTROL_MODE_SCROLLBAR:                    _itemsPerPage = (_entries) ? Math.min(_entries.length, _config.maxItems) : _config.maxItems;                    break;                case FeedComponentConfig.CONTROL_MODE_PAGINATION:                case FeedComponentConfig.CONTROL_MODE_NONE:                default:                    _itemsPerPage = getNumItemsViewable();                    break;            }        }        protected function getNumItemsViewable():uint        {            var numItems:uint = (_entries) ? _entries.length : _config.maxItems;            var margin:Number = (_config.controlMode == FeedComponentConfig.CONTROL_MODE_PAGINATION) ? FOOTER_HEIGHT : 0;            return Math.min(uint(Math.round((_rectangle.height - margin) / _config.itemHeight)), numItems);        }        protected function getListViewXMargin():Number        {            switch (_config.controlMode)            {                case FeedComponentConfig.CONTROL_MODE_SCROLLBAR:                    return 2 * SCROLLBAR_MARGIN + _scrollbarWidth;                case FeedComponentConfig.CONTROL_MODE_PAGINATION:                case FeedComponentConfig.CONTROL_MODE_NONE:                default:                    return 0;            }        }        protected function getFullViewXMargin():Number        {            switch (_config.controlMode)            {                case FeedComponentConfig.CONTROL_MODE_SCROLLBAR:                    return 0;                case FeedComponentConfig.CONTROL_MODE_PAGINATION:                case FeedComponentConfig.CONTROL_MODE_NONE:                default:                    return 2 * SCROLLBAR_MARGIN + _scrollbarWidth;            }        }        ///// Rendering methods        protected function addFullViewHeader():void        {            if (!_fullViewHeader)            {                // Create the header bar...                _fullViewHeader = new Sprite();                _fullViewHeader.graphics.beginFill(FULL_VIEW_HEADER_FOOTER_COLOR, FULL_VIEW_HEADER_FOOTER_ALPHA);                _fullViewHeader.graphics.drawRect(0, 0, _rectangle.width, HEADER_HEIGHT);                _fullViewHeader.graphics.endFill();                // Add the "BACK" button...                var listViewButtonBg:Sprite = new Sprite();                listViewButtonBg.graphics.beginFill(NAV_BUTTON_COLOR);                listViewButtonBg.graphics.lineTo(HEADER_NAV_BACK_BUTTON_WIDTH - HEADER_NAV_BACK_BUTTON_CURVE_SIZE_X, 0);                listViewButtonBg.graphics.curveTo(HEADER_NAV_BACK_BUTTON_WIDTH - HEADER_NAV_BACK_BUTTON_CURVE_SIZE_X, 0, HEADER_NAV_BACK_BUTTON_WIDTH, HEADER_NAV_BACK_BUTTON_CURVE_SIZE_Y);                listViewButtonBg.graphics.lineTo(HEADER_NAV_BACK_BUTTON_WIDTH, HEADER_NAV_BUTTON_HEIGHT - HEADER_NAV_BACK_BUTTON_CURVE_SIZE_Y);                listViewButtonBg.graphics.curveTo(HEADER_NAV_BACK_BUTTON_WIDTH, HEADER_NAV_BUTTON_HEIGHT - HEADER_NAV_BACK_BUTTON_CURVE_SIZE_Y, HEADER_NAV_BACK_BUTTON_WIDTH - HEADER_NAV_BACK_BUTTON_CURVE_SIZE_X, HEADER_NAV_BUTTON_HEIGHT);                listViewButtonBg.graphics.lineTo(0, HEADER_NAV_BUTTON_HEIGHT);                listViewButtonBg.graphics.lineTo(0, 0);                listViewButtonBg.graphics.lineTo(-HEADER_NAV_BACK_BUTTON_TRIANGLE_HEIGHT, 0.5 * HEADER_NAV_BUTTON_HEIGHT);                listViewButtonBg.graphics.lineTo(0, HEADER_NAV_BUTTON_HEIGHT);                listViewButtonBg.graphics.lineTo(0, HEADER_NAV_BUTTON_HEIGHT);                listViewButtonBg.graphics.endFill();                listViewButtonBg.y = 0.5 * (HEADER_HEIGHT - HEADER_NAV_BUTTON_HEIGHT);                listViewButtonBg.x = 20;                _fullViewHeader.addChild(listViewButtonBg);                var listViewTextField:TextField = TextUtils.getTextField();                listViewTextField.text = "BACK";                listViewTextField.setTextFormat(TextUtils.getTextFormat(HEADER_NAV_TEXT_FONT, HEADER_NAV_TEXT_SIZE, HEADER_NAV_TEXT_COLOR));                listViewTextField.x = listViewButtonBg.x + 0.5 * (HEADER_NAV_BACK_BUTTON_WIDTH - listViewTextField.textWidth - 0.5 * HEADER_NAV_BACK_BUTTON_TRIANGLE_HEIGHT) - 1;                listViewTextField.y = listViewButtonBg.y + 0.5 * (listViewButtonBg.height - listViewTextField.textHeight) - 1;                _fullViewHeader.addChild(listViewTextField);                var listViewHitArea:Sprite = new Sprite();                listViewHitArea.graphics.beginFill(0xFFFFFF, 0);                listViewHitArea.graphics.drawRect(0, 0, HEADER_NAV_BACK_BUTTON_WIDTH, HEADER_NAV_BUTTON_HEIGHT);                listViewHitArea.graphics.endFill();                listViewHitArea.x = listViewButtonBg.x;                listViewHitArea.y = listViewButtonBg.y;                _fullViewHeader.addChild(listViewHitArea);                // TDFD: Abstract into initButton(mouseOutAlpha, mouseOverAlpha, clickHandler);                listViewButtonBg.alpha = NAV_BUTTON_MOUSE_OUT_ALPHA;                Utils.initButton(listViewHitArea,                    showListView,                    function(e:Event):void { listViewButtonBg.alpha = NAV_BUTTON_MOUSE_OVER_ALPHA; },                    function(e:Event):void { listViewButtonBg.alpha = NAV_BUTTON_MOUSE_OUT_ALPHA; },                    function(e:Event):void { trace('down on list view'); listViewButtonBg.alpha = NAV_BUTTON_MOUSE_DOWN_ALPHA; });                // Add the "READ MORE" button...                var readMoreButtonBg:Sprite = new Sprite();                readMoreButtonBg.graphics.beginFill(NAV_BUTTON_COLOR);                readMoreButtonBg.graphics.drawRoundRect(0, 0, HEADER_NAV_READ_MORE_BUTTON_WIDTH, HEADER_NAV_BUTTON_HEIGHT, HEADER_NAV_BUTTON_CORNER_ELLIPSE_RADIUS);                readMoreButtonBg.graphics.endFill();                readMoreButtonBg.y = listViewButtonBg.y;                readMoreButtonBg.x = _rectangle.width - HEADER_NAV_READ_MORE_BUTTON_WIDTH - 10;                _fullViewHeader.addChild(readMoreButtonBg);                var readMoreTextField:TextField = TextUtils.getTextField();                readMoreTextField.text = "READ MORE";                readMoreTextField.setTextFormat(TextUtils.getTextFormat(HEADER_NAV_TEXT_FONT, HEADER_NAV_TEXT_SIZE, HEADER_NAV_TEXT_COLOR));                readMoreTextField.x = readMoreButtonBg.x + 0.5 * (readMoreButtonBg.width - readMoreTextField.textWidth) - 3;                readMoreTextField.y = readMoreButtonBg.y + 0.5 * (readMoreButtonBg.height - readMoreTextField.textHeight) - 1;                _fullViewHeader.addChild(readMoreTextField);                var readMoreHitArea:Sprite = new Sprite();                readMoreHitArea.graphics.beginFill(0xFFFFFF, 0);                readMoreHitArea.graphics.drawRect(0, 0, HEADER_NAV_READ_MORE_BUTTON_WIDTH, HEADER_NAV_BUTTON_HEIGHT);                readMoreHitArea.graphics.endFill();                readMoreHitArea.x = readMoreButtonBg.x;                readMoreHitArea.y = readMoreButtonBg.y;                _fullViewHeader.addChild(readMoreHitArea);                readMoreButtonBg.alpha = NAV_BUTTON_MOUSE_OUT_ALPHA;                Utils.initButton(readMoreHitArea,                    function(e:Event):void {                        _api.net.navigateToURL(_fullView.linkUrl, {window:"_blank"}, _metricsUtil.logArticleInteraction("Read more",  {source:"button"}));                    },                    function(e:Event):void { readMoreButtonBg.alpha = NAV_BUTTON_MOUSE_OVER_ALPHA; },                    function(e:Event):void { readMoreButtonBg.alpha = NAV_BUTTON_MOUSE_OUT_ALPHA; },                    function(e:Event):void { readMoreButtonBg.alpha = NAV_BUTTON_MOUSE_DOWN_ALPHA; });                _fullViewContainer.addChild(_fullViewHeader);            }        }        protected function addFullViewFooter():void        {            var shareControl:Sprite = _fullView.shareControl;            if (!shareControl || !_config.sharingOptions)            {                return;            }            if (!_fullViewFooter)            {                // Create the footer.                _fullViewFooter = new Sprite();                _fullViewFooter.graphics.beginFill(FULL_VIEW_HEADER_FOOTER_COLOR);                _fullViewFooter.graphics.drawRect(0, 0, _rectangle.width, FOOTER_HEIGHT);                _fullViewFooter.graphics.endFill();                _fullViewFooter.y = _rectangle.height - FOOTER_HEIGHT;                _fullViewContainer.addChild(_fullViewFooter);            }            else            {                // Remove existing share controls.                Utils.removeChildren(_fullViewFooter);            }            // Add the new share controls.            shareControl.x = _rectangle.width - shareControl.width - 5;            shareControl.y = 0.5 * (FOOTER_HEIGHT - shareControl.height);            _fullViewFooter.addChild(shareControl);        }        /**         * Only used in the "Navigation" control type.         */        protected function addPageNavigation():void        {            if (!_footer)            {                _footer = new Sprite();                _footer.visible = false;            }            else            {                Utils.removeChildren(_footer);                _footer.graphics.clear();            }            _footer.graphics.beginFill(FULL_VIEW_HEADER_FOOTER_COLOR, FULL_VIEW_HEADER_FOOTER_ALPHA);            //			var itemWidth:uint = (_items && _items.length > 0)            _footer.graphics.drawRect(0, 0, _rectangle.width, FOOTER_HEIGHT);            _footer.graphics.endFill();            _footer.y = _rectangle.height - FOOTER_HEIGHT;            addChild(_footer);            // Draw a nav element for each page, or only as many as will comfortably fit.            var numPages:uint = Math.ceil(_entries.length / _itemsPerPage);            trace('num pages is',numPages,'and entries are',_entries.length,'and items per page',_itemsPerPage);            var maxGotoPageNavButtons:uint = (_rectangle.width - 2 * (NEXT_BUTTON_WIDTH + FOOTER_PREV_NEXT_BUTTON_MARGIN)) / ( 2 * FOOTER_NAV_BUTTON_SIZE);            var numGotoPageNavButtons:uint = Math.min(numPages, maxGotoPageNavButtons);            var yPos:Number = 0.5 * (FOOTER_HEIGHT - FOOTER_NAV_BUTTON_SIZE);            var gotoNavButtonSpace:uint = numGotoPageNavButtons * FOOTER_NAV_BUTTON_SIZE * 2;            var startX:Number = 0.5 * (_rectangle.width - gotoNavButtonSpace) + 0.5 * FOOTER_NAV_BUTTON_SIZE;            var xPos:Number;            for (var i:uint = 0; i < numGotoPageNavButtons; i++)            {                xPos = startX + i * FOOTER_NAV_BUTTON_SIZE * 2;                var currentButton:Sprite = getPageNavButton(xPos, yPos, FOOTER_NAV_BUTTON_SIZE, i);                currentButton.name = 'button' + i;                currentButton.alpha = NAV_BUTTON_MOUSE_OUT_ALPHA;                _footer.addChild(currentButton);            }            // Add the "next" button.            _nextPageButton = new Sprite();            var oneThirdNextButtonHeight:Number = NEXT_BUTTON_HEIGHT / 3;            var oneHalfNextButtonWidth:Number = 0.5 * NEXT_BUTTON_WIDTH;            _nextPageButton.graphics.beginFill(NAV_BUTTON_COLOR);            _nextPageButton.graphics.drawRect(0, oneThirdNextButtonHeight, oneHalfNextButtonWidth, oneThirdNextButtonHeight);            _nextPageButton.graphics.moveTo(oneHalfNextButtonWidth, oneThirdNextButtonHeight);            _nextPageButton.graphics.lineTo(oneHalfNextButtonWidth, 0);            _nextPageButton.graphics.lineTo(NEXT_BUTTON_WIDTH, 0.5 * NEXT_BUTTON_HEIGHT);            _nextPageButton.graphics.lineTo(oneHalfNextButtonWidth, NEXT_BUTTON_HEIGHT);            _nextPageButton.graphics.lineTo(oneHalfNextButtonWidth, oneThirdNextButtonHeight);            _nextPageButton.graphics.endFill();            _nextPageButton.graphics.beginFill(0xFFFFFF, 0);            _nextPageButton.graphics.drawRect(oneHalfNextButtonWidth, 0, oneHalfNextButtonWidth, NEXT_BUTTON_HEIGHT);            _nextPageButton.graphics.endFill();            _nextPageButton.alpha = NAV_BUTTON_MOUSE_OUT_ALPHA;            Utils.initButton(_nextPageButton, function(e:Event):void{ gotoNextPage(false); }, showButtonMouseOver, showButtonMouseOut);            _nextPageButton.x = _rectangle.width - NEXT_BUTTON_WIDTH - FOOTER_PREV_NEXT_BUTTON_MARGIN;            _nextPageButton.y = 0.5 * (FOOTER_HEIGHT - NEXT_BUTTON_HEIGHT);            _footer.addChild(_nextPageButton);            // Add the "prev" button.            _prevPageButton = new Sprite();            _prevPageButton.graphics.beginFill(NAV_BUTTON_COLOR);            _prevPageButton.graphics.moveTo(0, 0.5 * NEXT_BUTTON_HEIGHT);            _prevPageButton.graphics.lineTo(oneHalfNextButtonWidth, 0);            _prevPageButton.graphics.lineTo(oneHalfNextButtonWidth, NEXT_BUTTON_HEIGHT);            _prevPageButton.graphics.lineTo(0, 0.5 * NEXT_BUTTON_HEIGHT);            _prevPageButton.graphics.drawRect(oneHalfNextButtonWidth, oneThirdNextButtonHeight, oneHalfNextButtonWidth, oneThirdNextButtonHeight);            _prevPageButton.graphics.endFill();            _prevPageButton.alpha = NAV_BUTTON_MOUSE_OUT_ALPHA;            Utils.initButton(_prevPageButton, gotoPrevPage, showButtonMouseOver, showButtonMouseOut);            _prevPageButton.x = FOOTER_PREV_NEXT_BUTTON_MARGIN;            _prevPageButton.y = 0.5 * (FOOTER_HEIGHT - NEXT_BUTTON_HEIGHT);            _footer.addChild(_prevPageButton);            // TDFD: Consider performance considerations of nested functions; this function is only called on each            // resize (ostensibly just once), but nonetheless you should consider the drawbacks.            function showButtonMouseOut(event:Event):void            {                (event.target as DisplayObject).alpha = NAV_BUTTON_MOUSE_OUT_ALPHA;            }            function showButtonMouseOver(event:Event):void            {                (event.target as DisplayObject).alpha = NAV_BUTTON_MOUSE_OVER_ALPHA;            }            function getPageNavButton(x:int, y:int, size:uint, page:uint):Sprite            {                var button:Sprite = new Sprite();                var radius:Number = 0.5 * size;                button.graphics.beginFill(NAV_BUTTON_COLOR);                button.graphics.drawCircle(x + radius, y + radius, radius);                button.graphics.endFill();				button.alpha = NAV_BUTTON_MOUSE_OUT_ALPHA;				                Utils.initButton(button, function(e:Event):void                {                    _metricsUtil.logFeedNav(String(page));                    gotoPage(page);                }, showGotoButtonMouseOver, showGotoButtonMouseOut);                return button;            }            function showGotoButtonMouseOver(event:Event):void            {                var target:DisplayObject = event.target as DisplayObject;                if (target.name.split('button')[1] != _currentPage)                {                    target.alpha = NAV_BUTTON_MOUSE_OVER_ALPHA;                }            }            function showGotoButtonMouseOut(event:Event):void            {                var target:DisplayObject = event.target as DisplayObject;                if (target.name.split('button')[1] != _currentPage)                {                    target.alpha = NAV_BUTTON_MOUSE_OUT_ALPHA;                }            }        }    }}