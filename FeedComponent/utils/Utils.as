package utils{	import flash.display.DisplayObjectContainer;	import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.external.ExternalInterface;	import flash.text.TextField;	import flash.text.TextFormat;		public class Utils	{		public static var _api:Object;		public function Utils()		{		}		// To be called before you can track an event.		public static function setApi(api:Object):void		{			_api = api;		}				public static function mytrace(...rest):void		{			var outputString:String = getStringFromRestParams(rest);			trace(outputString);			// _api.net.traceOut(outputString);			// printToContainerConsole(outputString);		}						public static function getStringFromRestParams(...rest):String		{			var outputString:String = "";			for (var i:uint = 0; i < rest.length; i++)			{				outputString += rest[i] + " ";			}						return outputString;		}		public static function initButton(button:Sprite, onClick:Function, onMouseOver:Function, onMouseOut:Function, onMouseDown:Function = null):void		{			button.addEventListener(MouseEvent.CLICK, onClick);			button.addEventListener(MouseEvent.MOUSE_OVER, onMouseOver);			button.addEventListener(MouseEvent.MOUSE_OUT, onMouseOut);						if (onMouseDown != null)			{				button.addEventListener(MouseEvent.MOUSE_DOWN, onMouseDown);                button.addEventListener(MouseEvent.MOUSE_UP, onMouseOver);			}						button.buttonMode = true;		}				/**		 * Removes all of the input Sprite's children, clears its graphics object, removes it from the display list,		 * and sets it to null.		 * 		 */		public static function destroySprite(sprite:Sprite):void		{			Utils.removeChildren(sprite);			sprite.parent.removeChild(sprite);			sprite.graphics.clear();			sprite = null;		}				public static function removeChildren(container:DisplayObjectContainer):void		{			var numChildren:uint = container.numChildren;			for (var i:int = numChildren - 1; i >= 0; i--)			{				container.removeChildAt(i);			}		}						/**		 * Given the size of an array to return, returns an array		 * of that size in order [0, 1, 2...]		 */		public static function getOrderedArray(size:uint):Array {			var array:Array = new Array(size);						for (var i:uint = 0; i < size; i++) {				array[i] = i;			}						return array;		}								/**		 * Given the size of an array to return, returns an array of that		 * size in random order.		 */		public static function getRandomOrderArray(size:uint):Array {			if (size < 3) {				return (size == 1) ? [0] : [1, 0];			}						var randomOrder:Array = getOrderedArray(size);						var temp:uint;			var random:uint;			for (var i:uint = 0; i < size; i++) {				random = Math.random() * size;				temp = randomOrder[i];				randomOrder[i] = randomOrder[random];				randomOrder[random] = temp;			}						// Make sure the randomization worked 'well' - i.e. that more			// than half of the elements are not in their original position.			var numSame:uint = 0;			for (i = 0; i < size; i++) {				if (randomOrder[i] == i) {					numSame++;				}			}						if (numSame > size / 2) {				return getRandomOrderArray(size);			}						return randomOrder;		}	}}